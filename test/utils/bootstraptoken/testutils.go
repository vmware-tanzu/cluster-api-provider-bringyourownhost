// Copyright 2021 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package bootstraptoken

import (
	"context"
	"fmt"
	"time"

	"github.com/vmware-tanzu/cluster-api-provider-bringyourownhost/agent/registration"
	"k8s.io/client-go/tools/clientcmd"
	clientcmdapi "k8s.io/client-go/tools/clientcmd/api"

	infrastructurev1beta1 "github.com/vmware-tanzu/cluster-api-provider-bringyourownhost/apis/infrastructure/v1beta1"
	certv1 "k8s.io/api/certificates/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	restclient "k8s.io/client-go/rest"
	bootstrapapi "k8s.io/cluster-bootstrap/token/api"
	bootstraputil "k8s.io/cluster-bootstrap/token/util"
	clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
	crClient "sigs.k8s.io/controller-runtime/pkg/client"
)

func CreateBootstrapKubeConfig(tempKubeconfigPath, bootstrapKubeconfigPath string, ttl time.Duration) error {
	config, err := registration.LoadRESTClientConfig(tempKubeconfigPath)
	if err != nil {
		return err
	}
	scheme := runtime.NewScheme()
	_ = infrastructurev1beta1.AddToScheme(scheme)
	_ = corev1.AddToScheme(scheme)
	_ = clusterv1.AddToScheme(scheme)
	_ = certv1.AddToScheme(scheme)
	k8sClient, err := crClient.New(config, crClient.Options{Scheme: scheme})
	if err != nil {
		return err
	}
	tokenstr, err := CreateBootstrapToken(context.TODO(), k8sClient, ttl)
	if err != nil {
		return err
	}
	err = WriteKubeconfigFromBootstrapToken(config, bootstrapKubeconfigPath, tokenstr)
	if err != nil {
		return err
	}
	return nil
}

func CreateBootstrapToken(ctx context.Context, c crClient.Client, ttl time.Duration) (string, error) {
	tokenStr, err := bootstraputil.GenerateBootstrapToken()
	if err != nil {
		return "", err
	}
	substrs := bootstraputil.BootstrapTokenRegexp.FindStringSubmatch(tokenStr)
	if len(substrs) != 3 { // nolint: gomnd
		return "", fmt.Errorf("the bootstrap token %q was not of the form %q", tokenStr, bootstrapapi.BootstrapTokenPattern)
	}
	tokenID := substrs[1]
	tokenSecret := substrs[2]
	secretName := "bootstrap-token-" + tokenID
	secretToken := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      secretName,
			Namespace: metav1.NamespaceSystem,
		},
		Type: bootstrapapi.SecretTypeBootstrapToken,
		Data: map[string][]byte{
			bootstrapapi.BootstrapTokenIDKey:               []byte(tokenID),
			bootstrapapi.BootstrapTokenSecretKey:           []byte(tokenSecret),
			bootstrapapi.BootstrapTokenExpirationKey:       []byte(time.Now().UTC().Add(ttl).Format(time.RFC3339)),
			bootstrapapi.BootstrapTokenUsageSigningKey:     []byte("true"),
			bootstrapapi.BootstrapTokenUsageAuthentication: []byte("true"),
			bootstrapapi.BootstrapTokenExtraGroupsKey:      []byte("system:bootstrappers:byoh"),
			bootstrapapi.BootstrapTokenDescriptionKey:      []byte("token generated by cluster-api-provider-bringyourownhost"),
		},
	}
	if err := c.Create(ctx, secretToken); err != nil {
		return "", err
	}
	return tokenStr, nil
}

func WriteKubeconfigFromBootstrapToken(clientConfig *restclient.Config, kubeconfigPath, token string) error {
	kubeconfigData := clientcmdapi.Config{
		Clusters: map[string]*clientcmdapi.Cluster{"default-cluster": {
			Server:                   clientConfig.Host,
			CertificateAuthorityData: clientConfig.CAData,
		}},
		AuthInfos: map[string]*clientcmdapi.AuthInfo{"default-auth": {
			Token: token,
		}},
		Contexts: map[string]*clientcmdapi.Context{"default-context": {
			Cluster:   "default-cluster",
			AuthInfo:  "default-auth",
			Namespace: "default",
		}},
		CurrentContext: "default-context",
	}
	// Marshal to disk
	return clientcmd.WriteToFile(kubeconfigData, kubeconfigPath)
}
